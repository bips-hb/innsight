% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/DeepLift.R
\name{DeepLift}
\alias{DeepLift}
\title{Deep Learning Important FeaTures (DeepLift) Method}
\description{
This is an implementation of the \emph{Deep Learning Important FeaTures
(DeepLift)} algorithm introduced by Shrikumar et al. (2017). It's a local
method for interpreting a single element \eqn{x} of the dataset concerning
a reference value \eqn{x'} and returns the contribution of each input
feature from the difference of the output (\eqn{y=f(x)}) and reference
output (\eqn{y'=f(x')}) prediction. The basic idea of this method is to
decompose the difference-from-reference prediction with respect to the
input features, i.e.
\deqn{\Delta y = y - y'  = \sum_i C(x_i).}
Compared to \emph{Layer-wise Relevance Propagation} (see \link{LRP}) is the
DeepLIFT method an exact decomposition and not an approximation, so we
get real contributions of the input features to the
difference-from-reference prediction. There are two ways to handle
activation functions: \emph{Rescale-Rule} and \emph{RevealCancel-Rule}.
}
\examples{
\dontshow{if (torch::torch_is_installed()) (if (getRversion() >= "3.4") withAutoprint else force)(\{ # examplesIf}
#----------------------- Example 1: Torch ----------------------------------
library(torch)

# Create nn_sequential model and data
model <- nn_sequential(
  nn_linear(5, 12),
  nn_relu(),
  nn_linear(12, 2),
  nn_softmax(dim = 2)
)
data <- torch_randn(25, 5)
ref <- torch_randn(1, 5)

# Create Converter
converter <- Converter$new(model, input_dim = c(5))

# Apply method DeepLift
deeplift <- DeepLift$new(converter, data, x_ref = ref)

# Print the result as a torch tensor
deeplift$get_result("torch.tensor")

# Plot the result for both classes
plot(deeplift, classes = 1:2)

# Plot the boxplot of all datapoints
boxplot(deeplift, classes = 1:2)

# ------------------------- Example 2: Neuralnet ---------------------------
library(neuralnet)
data(iris)

# Train a neural network
nn <- neuralnet((Species == "setosa") ~ Petal.Length + Petal.Width,
  iris,
  linear.output = FALSE,
  hidden = c(3, 2), act.fct = "tanh", rep = 1
)

# Convert the model
converter <- Converter$new(nn)

# Apply DeepLift with rescale-rule and a reference input of the feature
# means
x_ref <- matrix(colMeans(iris[, c(3, 4)]), nrow = 1)
deeplift_rescale <- DeepLift$new(converter, iris[, c(3, 4)], x_ref = x_ref)

# Get the result as a dataframe
deeplift_rescale$get_result(type = "data.frame")

# Plot the result for the first datapoint in the data
plot(deeplift_rescale, datapoint = 1)

# Plot the result as boxplots
boxplot(deeplift_rescale)

# ------------------------- Example 3: Keras -------------------------------
library(keras)

if (is_keras_available()) {
  data <- array(rnorm(10 * 32 * 32 * 3), dim = c(10, 32, 32, 3))

  model <- keras_model_sequential()
  model \%>\%
    layer_conv_2d(
      input_shape = c(32, 32, 3), kernel_size = 8, filters = 8,
      activation = "softplus", padding = "valid"
    ) \%>\%
    layer_conv_2d(
      kernel_size = 8, filters = 4, activation = "tanh",
      padding = "same"
    ) \%>\%
    layer_conv_2d(
      kernel_size = 4, filters = 2, activation = "relu",
      padding = "valid"
    ) \%>\%
    layer_flatten() \%>\%
    layer_dense(units = 64, activation = "relu") \%>\%
    layer_dense(units = 16, activation = "relu") \%>\%
    layer_dense(units = 2, activation = "softmax")

  # Convert the model
  converter <- Converter$new(model)

  # Apply the DeepLift method with reveal-cancel rule
  deeplift_revcancel <- DeepLift$new(converter, data,
    channels_first = FALSE,
    rule_name = "reveal_cancel"
  )

  # Plot the result for the first image and both classes
  plot(deeplift_revcancel, classes = 1:2)

  # Plot the result as boxplots for first class
  boxplot(deeplift_revcancel, classes = 1)

  # You can also create an interactive plot with plotly.
  # This is a suggested package, so make sure that it is installed
  library(plotly)
  boxplot(deeplift_revcancel, as_plotly = TRUE)
}

# ------------------------- Advanced: Plotly -------------------------------
# If you want to create an interactive plot of your results with custom
# changes, you can take use of the method plotly::ggplotly
library(ggplot2)
library(neuralnet)
library(plotly)
data(iris)

nn <- neuralnet(Species ~ .,
  iris,
  linear.output = FALSE,
  hidden = c(10, 8), act.fct = "tanh", rep = 1, threshold = 0.5
)
# create an converter for this model
converter <- Converter$new(nn)

# create new instance of 'DeepLift'
deeplift <- DeepLift$new(converter, iris[, -5])

# Get the ggplot and add your changes
p <- plot(deeplift, classes = 1, datapoint = 1:2) +
  theme_bw() +
  scale_fill_gradient2(low = "green", mid = "black", high = "blue")

# Now apply the method plotly::ggplotly with argument tooltip = "text"
plotly::ggplotly(p, tooltip = "text")
\dontshow{\}) # examplesIf}
}
\references{
A. Shrikumar et al. (2017) \emph{Learning important features through
propagating activation differences.}  ICML 2017, p. 4844-4866
}
\section{Super class}{
\code{\link[innsight:InterpretingMethod]{innsight::InterpretingMethod}} -> \code{DeepLift}
}
\section{Public fields}{
\if{html}{\out{<div class="r6-fields">}}
\describe{
\item{\code{x_ref}}{The reference input of size (1, dim_in) for the
interpretation.}

\item{\code{rule_name}}{Name of the applied rule to calculate the contributions
for the non-linear part of a Neural Network layer. Either
\code{"rescale"} or \code{"reveal_cancel"}.}
}
\if{html}{\out{</div>}}
}
\section{Methods}{
\subsection{Public methods}{
\itemize{
\item \href{#method-new}{\code{DeepLift$new()}}
\item \href{#method-plot}{\code{DeepLift$plot()}}
\item \href{#method-boxplot}{\code{DeepLift$boxplot()}}
\item \href{#method-clone}{\code{DeepLift$clone()}}
}
}
\if{html}{
\out{<details open ><summary>Inherited methods</summary>}
\itemize{
\item \out{<span class="pkg-link" data-pkg="innsight" data-topic="InterpretingMethod" data-id="get_result">}\href{../../innsight/html/InterpretingMethod.html#method-get_result}{\code{innsight::InterpretingMethod$get_result()}}\out{</span>}
}
\out{</details>}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-new"></a>}}
\if{latex}{\out{\hypertarget{method-new}{}}}
\subsection{Method \code{new()}}{
Create a new instance of the DeepLift method.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{DeepLift$new(
  converter,
  data,
  channels_first = TRUE,
  dtype = "float",
  ignore_last_act = TRUE,
  rule_name = "rescale",
  x_ref = NULL
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{converter}}{An instance of the R6 class \code{\link{Converter}}.}

\item{\code{data}}{The data for which the contribution scores are to be
calculated. It has to be an array or array-like format of size
(batch_size, dim_in).}

\item{\code{channels_first}}{Set the data format of the given data. Internally
the format \code{channels_first} is used, therefore the format of the given
data is required. Also use the default value \code{TRUE} if no convolutional
layers are used.}

\item{\code{dtype}}{The data type for the calculations. Use either \code{'float'}
(default) or \code{'double'}.}

\item{\code{ignore_last_act}}{Set this boolean value to include the last
activation, or not (default: \code{TRUE}). In some cases, the last activation
leads to a saturation problem.}

\item{\code{rule_name}}{Name of the applied rule to calculate the
contributions. Use one of \code{'rescale'} and \code{'reveal_cancel'}.}

\item{\code{x_ref}}{The reference input of size (1, dim_in) for the
interpretation. With the default value \code{NULL} you use an input
of zeros.}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-plot"></a>}}
\if{latex}{\out{\hypertarget{method-plot}{}}}
\subsection{Method \code{plot()}}{
This method visualizes the result of the selected method in a
\link[ggplot2:ggplot]{ggplot2::ggplot}. You can use the argument \code{datapoint} to select
the data points in the given data for the plot. In addition, the
individual classes for the plot can be selected with the argument
\code{classes}. The different results for the selected data points and
classes are visualized using the method \link[ggplot2:facet_grid]{ggplot2::facet_grid}.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{DeepLift$plot(
  datapoint = 1,
  classes = 1,
  aggr_channels = sum,
  as_plotly = FALSE
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{datapoint}}{An integer vector containing the numbers of the data
points whose result is to be plotted, e.g. \code{c(1,3)} for the first
and third data point in the given data. Default: \code{c(1)}.}

\item{\code{classes}}{An integer vector containing the numbers of the classes
whose result is to be plotted, e.g. \code{c(1,4)} for the first and fourth
class. Default: \code{c(1)}.}

\item{\code{aggr_channels}}{Pass a function to aggregate the channels. The
default function is \link[base:sum]{base::sum}, but you can pass an arbitrary function.
For example, the maximum \code{max} or minimum \code{min} over the channels or
only individual channels with \code{function(x) x[1]}.}

\item{\code{as_plotly}}{This boolean value (default: \code{FALSE}) can be used to
create an interactive plot based on the library \code{plotly}. This function
takes use of \link[plotly:ggplotly]{plotly::ggplotly}, hence make sure that the suggested
package \code{plotly} is installed in your R session. Advanced: You can first
output the results as a ggplot (\code{as_plotly = FALSE}) and then make
custom changes to the plot, e.g. other theme or other fill color. Then
you can manually call the function \code{ggplotly} to get an interactive
plotly plot.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
Returns either a \link[ggplot2:ggplot]{ggplot2::ggplot} (\code{as_plotly = FALSE}) or a
\link[plotly:plot_ly]{plotly::plot_ly} (\code{as_plotly = TRUE}) with the plotted results.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-boxplot"></a>}}
\if{latex}{\out{\hypertarget{method-boxplot}{}}}
\subsection{Method \code{boxplot()}}{
This function visualizes the results of this method in a boxplot, where
the type of visualization depends on the input dimension of the data.
By default a \link[ggplot2:ggplot]{ggplot2::ggplot} is returned, but with the argument
\code{as_plotly} an interactive \link[plotly:plot_ly]{plotly::plot_ly} plot can be created,
which however requires a successful installation of the package
\code{plotly}.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{DeepLift$boxplot(
  boxplot_data = "all",
  classes = 1,
  ref_datapoint = NULL,
  aggr_channels = mean,
  preprocess_FUN = abs,
  as_plotly = FALSE,
  individual_data = NULL,
  individual_max = 20
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{boxplot_data}}{By default ("all"), all available data is used to
calculate the boxplot information. However, this parameter can be used
to select a subset of them by passing the indices. E.g. with
\code{boxplot_data = c(1:10, 25, 26)} only the first \code{10} data points and
the 25th and 26th are used to calculate the boxplots.}

\item{\code{classes}}{An integer vector containing the numbers of the classes
whose result is to be plotted, e.g. \code{c(1,4)} for the first and fourth
class. Default: \code{c(1)}.}

\item{\code{ref_datapoint}}{This integer number determines the index for the
reference data point. In addition to the boxplots, it is displayed in
red color and is used to compare an individual result with the summary
statistics provided by the boxplot. With the default value (\code{NULL})
no individual data point is plotted. This index can be chosen with
respect to all available data, even if only a subset is selected with
argument \code{boxplot_data}.\cr
\strong{Note:} Because of the complexity of 3D inputs, this argument is used
only for 1D and 2D inputs and disregarded for 3D inputs.}

\item{\code{aggr_channels}}{Pass a function to aggregate the channels. The
default function is \link[base:mean]{base::mean}, but you can pass an arbitrary
function. For example, the maximum \code{max} or minimum \code{min} over the
channels or only individual channels with \code{function(x) x[1]}.\cr
\strong{Note:} This function is used only for 2D and 3D inputs.}

\item{\code{preprocess_FUN}}{This function is applied to the method's result
before calculating the boxplots. Since positive and negative values
often cancel each other out, the absolute value (\code{abs}) is used by
default. But you can also use the raw data (\code{function(x) x}) to see the
results' orientation, the squared data (\code{function(x) x^2}) to weight
the outliers higher or any other function.}

\item{\code{as_plotly}}{This boolean value (default: \code{FALSE}) can be used to
create an interactive plot based on the library \code{plotly} instead of
\code{ggplot2}. Make sure that the suggested package \code{plotly} is installed
in your R session.}

\item{\code{individual_data}}{Only relevant for a \code{plotly} plot with input
dimension \code{1} or \code{2}! This integer vector of data indices determines
the available data points in a dropdown menu, which are drawn in
individually analogous to \code{ref_datapoint} only for more data points.
With the default value \code{NULL} the first \code{individual_max} data points
are used.\cr
\strong{Note:} If \code{ref_datapoint} is specified, this data point will be
added to those from \code{individual_data} in the dropdown menu.}

\item{\code{individual_max}}{Only relevant for a \code{plotly} plot with input
dimension \code{1} or \code{2}! This integer determines the maximum number of
individual data points in the dropdown menu without counting
\code{ref_datapoint}. This means that if \code{individual_data} has more
than \code{individual_max} indices, only the first \code{individual_max} will
be used. Too high a number can significantly increase the runtime.}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-clone"></a>}}
\if{latex}{\out{\hypertarget{method-clone}{}}}
\subsection{Method \code{clone()}}{
The objects of this class are cloneable with this method.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{DeepLift$clone(deep = FALSE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{deep}}{Whether to make a deep clone.}
}
\if{html}{\out{</div>}}
}
}
}
